This File Contains Concepts Of Java Programming

    Java Terminology
    Features of Java
    JDK,JVM,JRE
    Java Basic Syntax
    Hello World Program
    Data Types
    Indentifiers
    Operators
    Variables
    Input/Output
    Constructors, this reference
    Access Modifiers
    Memory Allocation
    Flow Control
    Wrapper Class
    Arrays
    Strings
    Collection Frameworks
    Exception Handling
    Multi Threading
    Synchronization
    Serialization



JAVA
                                                    


Java Terminology

Before learning Java, one must be familiar with these common terms of Java.

1.  Java Virtual Machine(JVM):  This is generally referred to as JVM. There are three execution phases of a program. They are written, compile 
    and run the program.Writing a program is done by a java programmer like you and me.The compilation is done by the JAVAC compiler which is a 
    primary Java compiler included in the Java development kit (JDK). It takes the Java program as input and generates bytecode as output.
    In the Running phase of a program, JVM executes the bytecode generated by the compiler.Now, we understood that the function of Java Virtual
    Machine is to execute the bytecode produced by the compiler. Every Operating System has a different JVM but the output they produce after the 
    execution of bytecode is the same across all the operating systems. This is why Java is known as a platform-independent language.

2. Bytecode in the Development Process:  As discussed, the Javac compiler of JDK compiles the java source code into bytecode so that it can be 
    executed by JVM. It is saved as .class file by the compiler. To view the bytecode, a disassembler like javap can be used.

3. Java Development Kit(JDK): While we were using the term JDK when we learn about bytecode and JVM. So, as the name suggests, it is a complete 
    Java development kit that includes everything including compiler, Java Runtime Environment (JRE), java debuggers, java docs, etc.
    For the program to execute in java, we need to install JDK on our computer in order to create, compile and run the java program.

4. Java Runtime Environment (JRE): JDK includes JRE. JRE installation on our computers allows the java program to run, however,
    we cannot compile it. JRE includes a browser, JVM, applet support, and plugins. For running the java program, a computer needs JRE.

5. Garbage Collector: In Java, programmers can’t delete the objects. To delete or recollect that memory JVM has a program called Garbage Collector. 
    Garbage Collectors can recollect the objects that are not referenced. So Java makes the life of a programmer easy by handling memory management.
    However, programmers should be careful about their code whether they are using objects that have been used for a long time. Because Garbage 
    cannot recover the memory of objects being referenced.

------------------------------------------------------------------------------------------------------------------------------------------------------

Features of Java
    
1. Platform Independent: Compiler converts source code to bytecode and then the JVM executes the bytecode generated by the compiler. This bytecode
    can run on any platform be it Windows, Linux, or macOS which means if we compile a program on Windows, then we can run it on Linux and
    vice versa. Each operating system has a different JVM, but the output produced by all the OS is the same after the execution of the bytecode. 
    That is why we call java a platform-independent language.

2. Object-Oriented Programming Language: Organizing the program in the terms of a collection of objects is a way of object-oriented programming,
    each of which represents an instance of the class.
    
    The four main concepts of Object-Oriented programming are:

    Abstraction
    Encapsulation
    Inheritance
    Polymorphism
    
3. Simple:  Java is one of the simple languages as it does not have complex features like pointers, operator overloading, multiple inheritances, 
    and Explicit memory allocation. 

4. Robust:  Java language is robust which means reliable. It is developed in such a way that it puts a lot of effort into checking errors 
    as early as possible, that is why the java compiler is able to detect even those errors that are not easy to detect by another programming
    language.

5. Secure:  In java, we don’t have pointers, so we cannot access out-of-bound arrays i.e it shows ArrayIndexOutOfBound Exception if we try to do so.
    That’s why several security flaws like stack corruption or buffer overflow are impossible to exploit in Java. Also, java programs run in an
    environment that is independent of the os(operating system) environment which makes java programs more secure.

6. Distributed:  We can create distributed applications using the java programming language. Remote Method Invocation and Enterprise Java Beans
    are used for creating distributed applications in java. The java programs can be easily distributed on one or more systems that are connected
    to each other through an internet connection.

7. Multithreading:  Java supports multithreading. It is a Java feature that allows concurrent execution of two or more parts of a program for
    maximum utilization of the CPU.

8. Portable:  As we know, java code written on one machine can be run on another machine. The platform-independent feature of java in which its 
    platform-independent bytecode can be taken to any platform for execution makes java portable.

9. High Performance: Java architecture is defined in such a way that it reduces overhead during the runtime and at some times java uses Just In 
    Time (JIT) compiler where the compiler compiles code on-demand basics where it only compiles those methods that are called making applications 
    to execute faster.


------------------------------------------------------------------------------------------------------------------------------------------------------

JDK(Java Development Kit)

The Java Development Kit (JDK) is a cross-platformed software development environment that offers a collection of tools and libraries necessary 
for developing Java-based software applications and applets. It is a core package used in Java, along with the JVM (Java Virtual Machine) 
and the JRE (Java Runtime Environment). 

Mostly many get confused with JRE and JDK, if you are only interested in running Java programs on your machine then you can easily do it 
using Java Runtime Environment. However, if you would like to develop a Java-based software application then along with JRE you may need 
some additional necessary tools, which is called JDK.

                                                JDK=JRE+Development Tools


JVM(Java Virtual Machine)  

A run-time engine to run Java applications. JVM is the one that actually calls the main method present in a Java code. JVM is a part of JRE
Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to 
run on any other Java-enabled system without any adjustment. This is all possible because of JVM.

When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. 
This .class file goes into various steps when we run it. These steps together describe the whole JVM. 


                                            JRE = JVM+ set of libraries and other files


Java JIT Compiler

Bytecode is one of the most important features of java that aids in cross-platform execution. The way of converting bytecode to native
machine language for execution has a huge impact on its speed of it. These bytecodes have to be interpreted or compiled to proper machine
instructions depending on the instruction set architecture. Moreover, these can be directly executed if the instruction architecture is bytecode 
based.

Interpreting the bytecode affects the speed of execution. In order to improve performance, JIT compilers interact with the Java Virtual 
Machine (JVM) at run time and compile suitable bytecode sequences into native machine code. While using a JIT compiler, the hardware is able to 
execute the native code, as compared to having the JVM interpret the same sequence of bytecode repeatedly and incurring overhead for the
translation process. This subsequently leads to performance gains in the execution speed, unless the compiled methods are executed less frequently.




Byte Code 

Byte code is an intermediate code between the source code and machine code. It is a low-level code that is the result of the compilation of a 
source code which is written in a high-level language. It is processed by a virtual machine like Java Virtual Machine (JVM).

Byte code is a non-runnable code after it is translated by an interpreter into machine code then it is understandable by the machine. 
It is compiled to run on JVM, any system having JVM can run it irrespective of their operating system. That’s why Java is platform-independent.
Byte code is referred to as a Portable code.

Machine Code:

Machine code is a set of instructions that is directly machine-understandable and it is processed by the Central Processing Unit (CPU).
Machine code is in binary (0’s and 1’s) format which is completely different from the byte code and source code. It is regarded as the most 
lowest-level representation of the source code. Machine code is obtained after compilation or interpretation. It is also called machine language.

------------------------------------------------------------------------------------------------------------------------------------------------------

JAVA Basic Syntax


CLASS AND OBJECT

A class in Java is a set of objects which shares common characteristics/ behavior and common properties/ attributes.
It is a user-defined blueprint or prototype from which objects are created.
For example, Student is a class while a particular student named Anunay is an object.

Declaration

        access_modifier class <class_name>
        {  
            data member;  
            method;  
            constructor;
            nested class;
        }

How to Create an Object of a Class

Using new Keyword

It is most common and used way to create an object in Java

        // creating object of class Test
        Test t = new Test();



        //This following code may be difficult to understand at this point just have a glance at how an object is created and called.
        
        class Lamp {
          
          // stores the value for light, true if light is on or else false if light is off
          boolean isOn;
        
          // method to turn on the light
          void turnOn() {
            isOn = true;
            System.out.println("Light on? " + isOn);
        
          }
        
          // method to turnoff the light
          void turnOff() {
            isOn = false;
            System.out.println("Light on? " + isOn);
          }
        }

        class Main {
          public static void main(String[] args) {
        
            // create objects led and halogen
            Lamp led = new Lamp();
            Lamp halogen = new Lamp();
        
            // turn on the light by calling method turnOn()
            led.turnOn();
        
            // turn off the light by calling method turnOff()
            halogen.turnOff();
          }
        }
------------------------------------------------------------------------------------------------------------------------------------------------------

Naming Conventions in Java 
    
In java, it is good practice to name class, variables, and methods name as what they are actually supposed to do instead of naming them randomly. 
They must be followed while developing software in java for good maintenance and readability of code. Java uses CamelCase as a practice for
writing names of methods, variables, classes, packages, and constants. 
    
Camel’s case in java programming consists of compound words or phrases such that each word or abbreviation begins with a capital letter 
or first word with a lowercase letter, rest all with capital.

Type 1: Classes and Interfaces

Class names should be nouns, in mixed cases with the first letter of each internal word capitalized. Interfaces names should also be capitalized 
just like class names. Use whole words and must avoid acronyms and abbreviations.

                Classes: class Student { }
                         class Integer {}
                         class Scanner {}
                         
                Interfaces : Runnable
                             Remote
                             Serializable 

Type 2: Methods 

Methods should be verbs, in mixed case with the first letter lowercase and with the first letter of each internal word capitalized.
    

Type 3: Variables

Variable names should be short yet meaningful. 

Variable names should not start with underscore _ or dollar sign $ characters, even though both are allowed.
One-character variable names should be avoided except for temporary variables.
Common names for temporary variables are i, j, k, m, and n for integers; c, d, and e for characters.

------------------------------------------------------------------------------------------------------------------------------------------------------
    
Java Hello World Program
    

            class HelloWorld {
            // Your program begins with a call to main().
            public static void main(String args[])
            {
                // Prints "Hello, World" 
                System.out.println("Hello, World");
            }
        }


In the Java programming language, every application must contain a main method. The main function(method) is the entry point of your Java 
application, and it’s mandatory in a Java program. whose signature in Java is: 

        public static void main(String[] args)
    
Explanation of the above syntax

public: So that JVM can execute the method from anywhere.
static: The main method is to be called without an object. The modifiers are public and static can be written in either order.
void: The main method doesn’t return anything.
String[]: The main method accepts a single argument, i.e., an array of elements of type String.
main(): Name configured in the JVM. The main method must be inside the class definition. The compiler executes the codes starting always from 
        the main function.

------------------------------------------------------------------------------------------------------------------------------------------------------

DATA TYPES

Data types in Java are of different sizes and values that can be stored in the variable that is made as per convenience and circumstances 
to cover up all test cases. Java has two categories in which data types are segregated 

Primitive Data Type: Boolean, char, int, short, byte, long, float, and double
Non-Primitive Data Type: String, Array, etc.

	Boolean - 1 bit   
	byte - 8 bits     
	char - 16 bits    
	short - 16 bits   
	int - 32 bits    
	long - 64 buts    
	float - 32 bits
	double - 64 bits

------------------------------------------------------------------------------------------------------------------------------------------------------

IDENTIFIERS
    

Rules For Defining Java Identifiers

There are certain rules for defining a valid Java identifier. These rules must be followed, otherwise, we get a compile-time error.
These rules are also valid for other languages like C, and C++. 

The only allowed characters for identifiers are all alphanumeric characters([A-Z],[a-z],[0-9]), ‘$‘(dollar sign) and ‘_‘ (underscore).
For example “geek@” is not a valid Java identifier as it contains a ‘@’ a special character.
Identifiers should not start with digits([0-9]). For example “123geeks” is not a valid Java identifier.
Java identifiers are case-sensitive.
There is no limit on the length of the identifier but it is advisable to use an optimum length of 4 – 15 letters only.
Reserved Words can’t be used as an identifier. For example “int while = 20;” is an invalid statement as a while is a reserved word. 
    

Examples of valid identifiers : 
        
        MyVariable
        MYVARIABLE
        myvariable
        x
        i
        x1
        i1
        _myvariable
        $myvariable
        sum_of_array
        geeks123

Examples of invalid identifiers : 

        My Variable  // contains a space
        123geeks   // Begins with a digit
        a+c // plus sign is not an alphanumeric character
        variable-2 // hyphen is not an alphanumeric character
        sum_&_difference // ampersand is not an alphanumeric character

------------------------------------------------------------------------------------------------------------------------------------------------------

OPERATORS

1. Arthimetic Operators

    
These are used to perform simple arithmetic operations on primitive data types. 
        
        * : Multiplication
        / : Division
        % : Modulo- for remainder ex: 10%8 = 2
        + : Addition
        – : Subtraction

2. Unary Operators
    

Unary operators need only one operand. They are used to increment, decrement, or negate a value. 
        
        – : Unary minus, used for negating the values.
        + : Unary plus  It performs an automatic conversion to int when the type of its operand is the byte, char, or short. 
        ++ : Increment operator, used for incrementing the value by 1. There are two varieties of increment operators. 
        Post-Increment: Value is first used for computing the result and then incremented.(a++)
        Pre-Increment: Value is incremented first, and then the result is computed.(++a)
        – –  : Decrement operator, used for decrementing the value by 1. There are two varieties of decrement operators. 
        Post-decrement: Value is first used for computing the result and then decremented.(a--)
        Pre-Decrement: The value is decremented first, and then the result is computed.(--a)
        ! : Logical not operator, used for inverting a boolean value. changing from false to true or vice versa

3. Assignment Operator

    
‘=’ Assignment operator is used to assign a value to any variable. It has right-to-left associativity, i.e. value given on the right-hand side of 
the operator is assigned to the variable on the left, and therefore right-hand side value must be declared before using it or should be a constant. 

The general format of the assignment operator is:

variable = value;

In many cases, the assignment operator can be combined with other operators to build a shorter version of the statement called a Compound Statement. For example, instead of a = a+5, we can write a += 5. 

        +=, for adding the left operand with the right operand and then assigning it to the variable on the left.
        -=, for subtracting the right operand from the left operand and then assigning it to the variable on the left.
        *=, for multiplying the left operand with the right operand and then assigning it to the variable on the left.
        /=, for dividing the left operand by the right operand and then assigning it to the variable on the left.
        %=, for assigning the modulo of the left operand by the right operand and then assigning it to the variable on the left.

For example, instead of a = a+5, we can write a += 5. 

    
4. Relational Operators

These operators are used to check for relations like equality, greater than, and less than. They return boolean results after the comparison 
and are extensively used in looping statements as well as conditional if-else statements
Some of the relational operators are- 

        ==, Equal to returns true if the left-hand side is equal to the right-hand side.
        !=, Not Equal to returns true if the left-hand side is not equal to the right-hand side.
        <, less than: returns true if the left-hand side is less than the right-hand side.
        <=, less than or equal to returns true if the left-hand side is less than or equal to the right-hand side.
        >, Greater than: returns true if the left-hand side is greater than the right-hand side.
        >=, Greater than or equal to returns true if the left-hand side is greater than or equal to the right-hand side.


    
5. Logical Operators

    
These operators are used to perform “logical AND” and “logical OR” operations, i.e., a function similar to AND gate and OR gate in digital
electronics. One thing to keep in mind is the second condition is not evaluated if the first one is false, i.e., it has a short-circuiting effect. 
Used extensively to test for several conditions for making a decision. Java also has “Logical NOT”, which returns true when the condition is false 
and vice-versa

Conditional operators are:

        &&, Logical AND: returns true when both conditions are true.
        ||, Logical OR: returns true if at least one condition is true.
        !, Logical NOT: returns true when a condition is false and vice-versa


6. Ternary operator

    
The ternary operator is a shorthand version of the if-else statement. It has three operands and hence the name Ternary.

The general format is:

        condition ? if true : if false
The above statement means that if the condition evaluates to true, then execute the statements after the ‘?’ else execute the statements after
the ‘:’.  

        Sample Code:
        
        // Java program to illustrate max of three numbers using ternary operator.
        public class operators {
            public static void main(String[] args)
            {
                int a = 20, b = 10, c = 30, result;
        
                // result holds max of three numbers
                result = ((a > b) ? (a > c) ? a : c : (b > c) ? b : c);
                System.out.println("Max of three numbers = " + result);
            }
        }


7. Bitwise Operators

    
These operators are used to perform the manipulation of individual bits of a number. They can be used with any of the integer types.
They are used when performing update and query operations of the Binary indexed trees. 

        &, Bitwise AND operator: returns bit by bit AND of input values.
        |, Bitwise OR operator: returns bit by bit OR of input values.
        ^, Bitwise XOR operator: returns bit-by-bit XOR of input values.
        ~, Bitwise Complement Operator: This is a unary operator which returns the one’s complement representation of the input value, i.e.,
        with all bits inverted.

Sample Code:

        // Java Program to implement bitwise operators
        import java.io.*;
        
        // Driver class
        class GFG {
            public static void main(String[] args)
            {
                // Bitwise operators
                int d = 0b1010;
                int e = 0b1100;
                System.out.println("d & e: " + (d & e));  // output will be 8
                System.out.println("d | e: " + (d | e));  // output will be 14
                System.out.println("d ^ e: " + (d ^ e));  // output will be 6
                System.out.println("~d: " + (~d));        // output will be -11
                System.out.println("d << 2: " + (d << 2));  // output will be 40
                System.out.println("e >> 1: " + (e >> 1));   // output will be 40
                System.out.println("e >>> 1: " + (e >>> 1));  // output will be 6
            }
        }


8. Shift Operators

    
These operators are used to shift the bits of a number left or right, thereby multiplying or dividing the number by two, respectively. 
They can be used when we have to multiply or divide a number by two. General format- 

                     number  shift_op  number_of_places_to_shift;

	<<, Left shift operator: shifts the bits of the number to the left and fills 0 on voids left as a result. Similar effect as multiplying the number with some power of two
	>>, Signed Right shift operator: shifts the bits of the number to the right and fills 0 on voids left as a result. The leftmost bit depends on the sign of the initial number 
	>>>, Unsigned Right shift operator: shifts the bits of the number to the right and fills 0 on voids left as a result. The leftmost bit is set to 0

------------------------------------------------------------------------------------------------------------------------------------------------------

Variables


In Java, Variables are the data containers that save the data values during Java program execution. Every Variable in Java is assigned a 
data type that designates the type and quantity of value it can hold. A variable is a memory location name for the data.


Java variable is a name given to a memory location. It is the basic unit of storage in a program.
The value stored in a variable can be changed during program execution.
Variables in Java are only a name given to a memory location. All the operations done on the variable affect that memory location.
In Java, all variables must be declared before use.


                                   int count; // declaring a variable
                                   count = 10; // initializing a variable   
                                   we can write directly   int count = 10; which is easy and better option


Types of Variables


1. Local Variables

A variable defined within a block or method or constructor is called a local variable. 

These variables are created when the block is entered, or the function is called and destroyed after exiting from the block or when the call 
returns from the function. The scope of these variables exists only within the block in which the variables are declared, i.e., we can access 
these variables only within that block. Initialization of the local variable is mandatory before using it in the defined scope.
        
        //Program to implement Local Variables
        import java.io.*;
        
        class Java {
        	public static void main(String[] args)
        	{
        		// Declared a Local Variable
        		int var = 10;
        
        		// This variable is local to this main method only
        		System.out.println("Local Variable: " + var);   // Output Local Variable: 10
        	}
        }


2. Instance Variables
    
Instance variables are non-static variables and are declared in a class outside of any method, constructor, or block. 

As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the 
object is destroyed. Unlike local variables, we may use access specifiers for instance variables. If we do not specify any access specifier, 
then the default access specifier will be used. Initialization of an instance variable is not mandatory. Its default value is dependent on the
data type of variable. For String it is null, for float it is 0.0f, for int it is 0, for Wrapper classes like Integer it is null, etc.
Instance variables can be accessed only by creating objects. We initialize instance variables using constructors while creating an object.
We can also use instance blocks to initialize the instance variables.

        
        Program to demonstrate Instance Variables
        import java.io.*;
        
        class Java {
        
        	// Declared Instance Variable
        	public String geek;
        	public int i;
        	public Integer I;
        	public Java()
        	{
        		// Default Constructor initializing Instance Variable
        		this.geek = "Shubham Jain";
        	}
        
        	// Main Method
        	public static void main(String[] args)
        	{
        		// Object Creation
        		Java name = new Java();
        
        		// Displaying O/P
        		System.out.println("Geek name is: " + name.geek);
        		System.out.println("Default value for int is " + name.i);
        	
        		// toString() called internally
        		System.out.println("Default value for Integer is " + name.I);
        	}
        }


Just take a glance we will learn in depth of what is a constructor and this. reference  soon



Static Variables
    
Static variables are also known as class variables. 

These variables are declared similarly to instance variables. The difference is that static variables are declared using the static keyword within
a class outside of any method, constructor, or block. Unlike instance variables, we can only have one copy of a static variable per class, 
irrespective of how many objects we create. Static variables are created at the start of program execution and destroyed automatically when
execution ends. Initialization of a static variable is not mandatory. Its default value is dependent on the data type of variable.
For String it is null, for float it is 0.0f, for int it is 0, for Wrapper classes like Integer it is null, etc.


        // Java Program to demonstrate Static variables
        import java.io.*;
        
        class GFG {
        	// Declared static variable
        	public static String geek = "Shubham Jain";
        
        	public static void main(String[] args)
        	{
        
        		t
        		// creation Displaying O/P GFG.geek --> using the static variable
        		System.out.println("Geek Name is : " + GFG.geek);
        
        		// static int c=0;
        		// above line,when uncommented, will throw an error as static variables cannot be declared locally.
        	}
        }

Scope of a Variable 

    
Member Variables (Class Level Scope)

These variables must be declared inside class (outside any function). They can be directly accessed anywhere in class. 

        public class Test
        {
            // All variables defined directly inside a class  are member variables
            int a;
            private String b;
            void method1() {....}
            int method2() {....}
            char c;
        }

Local Variables (Method Level Scope)


Variables declared inside a method have method level scope and can’t be accessed outside the method. 
Local variables don’t exist after method’s execution is over. 


        public class Test
        {
            void method1() 
            {
               // Local variable (Method level scope)
               int x;
            }
        }


Loop Variables (Block Scope) 


A variable declared inside pair of brackets “{” and “}” in a method has scope within the brackets only.

    
        public class Test
        {
            public static void main(String args[])
            {
                {
                    // The variable x has scope within
                    // brackets
                    int x = 10;
                    System.out.println(x);
                }
                
                // Uncommenting below line would produce error since variable x is out of scope.
        
                // System.out.println(x); 
            }
        }

------------------------------------------------------------------------------------------------------------------------------------------------------

INPUT / OUTPUT

How to Take Input From User in Java?
	
Java brings various Streams with its I/O package that helps the user perform all the Java input-output operations. These streams support 
all types of objects, data types, characters, files, etc. to fully execute the I/O operations. Input in Java can be with certain methods 
mentioned below in the article.

Methods to Take Input in Java
	
There are two ways by which we can take Java input from the user or from a file

BufferedReader Class
Scanner Class


1. Using BufferedReader Class for String Input In Java
	
It is a simple class that is used to read a sequence of characters. It has a simple function read that reads a character, another read 
which reads an array of characters, and a readLine() function which reads a line.

InputStreamReader() is a function that converts the input stream of bytes into a stream of characters so that it can be read as 
BufferedReader expects a stream of characters. BufferedReader can throw checked Exceptions.

        Program for taking user input using BufferedReader Class
        import java.io.*;
        
        class GFG {
        
            // Main Method
            public static void main(String[] args)
                throws IOException
            {
                // Creating BufferedReader Object InputStreamReader converts bytes to stream of character
                BufferedReader bfn = new BufferedReader(new InputStreamReader(System.in));
        
                // String reading internally
                String str = bfn.readLine();
        
                // Integer reading internally
                int it = Integer.parseInt(bfn.readLine());
        
                // Printing String
                System.out.println("Entered String : " + str);
        
                // Printing Integer
                System.out.println("Entered Integer : " + it);
            }
        }


We use Scanner class method only everywhere Using Scanner Class for Taking Input in Java

	
It is an advanced version of BufferedReader which was added in later versions of Java. The scanner can read formatted input. 
It has different functions for different types of data types. The scanner is much easier to read as we don’t have to write throws as 
there is no exception thrown by it. It contains predefined functions to read an Integer, Character, and other data types as well.

	
Syntax of Scanner class
	
	Scanner scn = new Scanner(System.in);  


Importing Scanner Class
	
‘To use the Scanner we need to import the Scanner class from the util package as


        	
        import java.util.Scanner;  
        
        Java Program to show how to take input from user using Scanner Class
        
        import java.util.*;
        
        class GFG {
        
            public static void main(String[] args)
            {
                // Scanner definition
                Scanner scn = new Scanner(System.in);
        
                // input is a string ( one word ) read by next() function
                String str1 = scn.next();
        
                // print String
                System.out.println("Entered String str1 : " + str1);
        
                // input is a String ( complete Sentence ) read by nextLine()function
                String str2 = scn.nextLine();
        
                // print string
                System.out.println("Entered String str2 : " + str2);
        
                // input is an Integer read by nextInt() function
                int x = scn.nextInt();
        
                // print integer
                System.out.println("Entered Integer : " + x);
        
                // input is a floatingValue read by nextFloat() function
                float f = scn.nextFloat();
        
                // print floating value
                System.out.println("Entered FloatValue : " + f);
            }
        }

Used While taking Input:

        nextBoolean()                       Used for reading Boolean value                    
        nextByte()                          Used for reading Byte value
        nextDouble()                        Used for reading Double value
        nextFloat()                         Used for reading Float value
        nextInt()                           Used for reading Int value
        nextLine()                          Used for reading Line value
        nextLong()                          Used for reading Long value
        nextShort()                         Used for reading Short value
        
Scanner Syntax: 

        Scanner in = new Scanner(System.in);
        String s = in.nextLine();



Parts of System.out.println()
	
The statement can be broken into 3 parts which can be understood separately:

System: It is a final class defined in the java.lang package.
	
out: This is an instance of PrintStream type, which is a public and static member field of the System class.
	
println(): As all instances of the PrintStream class have a public method println(), we can invoke the same on out as well. This is an upgraded 
version of print(). It prints any argument passed to it and adds a new line to the output. We can assume that System.out represents 
the Standard Output Stream.


------------------------------------------------------------------------------------------------------------------------------------------------------

Constructors

	
In Java, a Constructor is a block of codes similar to the method. It is called when an instance of the class is created. At the time of 
calling the constructor, memory for the object is allocated in the memory. It is a special type of method that is used to initialize the object. 
Every time an object is created using the new() keyword, at least one constructor is called.
        
        Program to demonstrate Constructor
        import java.io.*;
        
        // Driver Class
        class Geeks {
          
            // Constructor
            Geeks()
            {
                
                System.out.println("Constructor Called");
            }
        
            public static void main(String[] args)
            {
                Geeks geek = new Geeks();
            }
        }


When Java Constructor is called?
	
Each time an object is created using a new() keyword, at least one constructor (it could be the default constructor) is invoked to assign initial 
values to the data members of the same class. Rules for writing constructors are as follows:

The constructor(s) of a class must have the same name as the class name in which it resides.
A constructor in Java can not be abstract, final, static, or Synchronized.
Access modifiers can be used in constructor declaration to control its access i.e which other class can call the constructor.


Types of Constructors in Java

Default Constructor in Java
	
A constructor that has no parameters is known as default the constructor. A default constructor is invisible. And if we write a constructor
with no arguments, the compiler does not create a default constructor. It is taken out. It is being overloaded and called a 
parameterized constructor. The default constructor changed into the parameterized constructor. But Parameterized constructor can’t change the 
default constructor. The default constructor can be implicit or explicit. If we don’t define explicitly, we get an implicit default constructor. 
If we manually write a constructor, the implicit one is overridded.

        Program to demonstrate Default Constructor
        import java.io.*;
        
        class GFG {
        
            // Default Constructor
            GFG() { System.out.println("Default constructor"); }
        
            public static void main(String[] args)
            {
                GFG hello = new GFG();
            }
        }


Parameterized Constructor in Java
	
A constructor that has parameters is known as parameterized constructor. If we want to initialize fields of the class with our own values, then 
use a parameterized constructor.


        // Java Program for Parameterized Constructor
        import java.io.*;
        class Geek {
            // data members of the class.
            String name;
            int id;
            Geek(String name, int id)
            {
                this.name = name;
                this.id = id;
            }
        }
        class GFG {
            public static void main(String[] args)
            {
                // This would invoke the parameterized constructor.
                Geek geek1 = new Geek("Avinash", 68);
                System.out.println("GeekName :" + geek1.name
                                   + " and GeekId :" + geek1.id);
            }
        }


	
Copy Constructor in Java
	
Unlike other constructors copy constructor is passed with another object which copies the data available from the passed object to the newly
created object.

Note: In Java,there is no such inbuilt copy constructor available like in other programming languages such as C++, instead we can create our 
own copy constructor by passing the object of the same class to the other instance(object) of the class.


	
        // Java Program for Copy Constructor
        import java.io.*;
        
        class Geek {
            // data members of the class.
            String name;
            int id;
        
            // Parameterized Constructor
            Geek(String name, int id)
            {
                this.name = name;
                this.id = id;
            }
        
            // Copy Constructor
            Geek(Geek obj2)
            {
                this.name = obj2.name;
                this.id = obj2.id;
            }
        }
        class GFG {
            public static void main(String[] args)
            {
                // This would invoke the parameterized constructor.
                System.out.println("First Object");
                Geek geek1 = new Geek("Avinash", 68);
                System.out.println("GeekName :" + geek1.name + " and GeekId :" + geek1.id);
        
                System.out.println();
        
                // This would invoke the copy constructor.
                Geek geek2 = new Geek(geek1);
                System.out.println( "Copy Constructor used Second Object");
                System.out.println("GeekName :" + geek2.name + " and GeekId :" + geek2.id);
            }
        }

------------------------------------------------------------------------------------------------------------------------------------------------------

this reference


‘this’ is a reference variable that refers to the current object, or can be said “this” in Java is a keyword that refers to the current object 
instance. It can be used to call current class methods and fields, to pass an instance of the current class as a parameter, and to differentiate 
between the local and instance variables. Using “this” reference can improve code readability and reduce naming conflicts.


        
        Program to implement Java this reference
        
        public class Person {
        
        	// Fields Declared
        	String name;
        	int age;
        
        	// Constructor
        	Person(String name, int age)
        	{
        		this.name = name;
        		this.age = age;
        	}
        
        	// Getter for name
        	public String get_name() { return name; }
        
        	// Setter for name
        	public void change_name(String name)
        	{
        		this.name = name;
        	}
        
        	// Method to Print the Details of the person
        	public void printDetails()
        	{
        		System.out.println("Name: " + this.name);
        		System.out.println("Age: " + this.age);
        		System.out.println();
        	}
        	public static void main(String[] args)
        	{
        		// Objects Declared
        		Person first = new Person("ABC", 18);
        		Person second = new Person("XYZ", 22);
        
        		first.printDetails();
        		second.printDetails();
        
        		first.change_name("PQR");
        		System.out.println("Name has been changed to: "
        						+ first.get_name());
        	}
        }

Output:

        Name: ABC
        Age: 18
        
        Name: XYZ
        Age: 22
        
        Name has been changed to: PQR


------------------------------------------------------------------------------------------------------------------------------------------------------

Access Modifiers

	
Modifier 1: Public Access Modifiers

	
If a class is declared as public then we can access that class from anywhere.

In the below example we are creating a package pack1 inside that package we declare a class A which is public and inside that class, 
we declare a method m1 which is also public. Now we create another package pack2 and inside that pack2 we import pack1 and declare a class B and
in class B’s main method we create an object of type class A and trying to access the data of method m1
        
        program to showcase the example of public access modifier
        
        // creating a package
        package pack1;
        
        // import required packages
        import java.io.*;
        import java.util.*;
        
        // declaring a public class
        public class A {
        	
        	// declaring method m1
        	public void m1() { System.out.println("GFG"); }
        }



        // creating a package
        package pack2;
        
        // import required packages
        import java.io.*;
        import java.util.*;
        
        // importing package pack1
        import pack1.A;
        
        // driver class
        class B {
        	public static void main(String[] args){
	 
        	// creating an object of type class A
        		A a = new A();
        		
        		// accessing the method m1()
        		a.m1();
        	}
        }


Modifier 2: Protected Access Modifier


This modifier can be applied to the data member, method, and constructor, but this modifier can’t be applied to the top-level classes and interface.

A member is declared as protected as we can access that member within the current package and only in the child class of the outside package


Java program to showcase the exampleof protected access modifier

        // import required packages
        import java.io.*;
        import java.util.*;
        
        // declaring a parent class A
        class A {
        	
        	// declaring a protected method m1()
        	protected void m1() { System.out.println("GFG"); }
        }

creating a child class by extending the class A

        class B extends A {
        	
        	// main method
        	public static void main(String[] args)
        	{
        		// creating an object of parent class
        		// using parent reference
        		A a = new A();
        		
        		/// calling method m1
        		a.m1();
        		
        		// creating an object of child class
        		// using child reference
        		B b = new B();
		
        		// calling method m1
        		b.m1();
        		
        		// creating an object of child class
        		// using parent reference
        		A a1 = new B();
        		
        		// calling m1 method
        		a1.m1();
        	}
        }



Private Access Modifiers

	
This modifier is not applicable for top-level classes or interfaces. It is only applicable to constructors, methods, and fields inside the classes.  

If a variable or methods or constructor is declared as private then we can access them only from within the class i.e from outside
the class we can’t access them


Java program to showcase the example  of private access modifier

        // import required packages
        import java.io.*;
        
        import java.util.*;
        
        // helper class
        class A {
        	// helper method
        	private void m1() { System.out.println("GFG"); }
        }

        // driver class
        class B {
        	public static void main(String[] args)
        	{
        		// creating an object of type class A
        		A a = new A();
        		
        		// accessing the method m1()
        		a.m1();
        	}
        }

------------------------------------------------------------------------------------------------------------------------------------------------------

Memory Management


In every programming language, the memory is a vital resource and is also scarce in nature. Hence it’s essential that the memory is managed 
thoroughly without any leaks. Allocation and deallocation of memory is a critical task and requires a lot of care and consideration.
However in Java, unlike other programming language, the JVM and to be specific Garbage Collector has the role of managing memory allocation so 
that the programmer needs not to. Whereas in other programming languages such as C the programmer has direct access to the memory who allocates
memory in his code, thereby creating a lot of scope for leaks.



In Java, all objects are dynamically allocated on Heap. This is different from C++ where objects can be allocated memory either on Stack or on Heap.
In JAVA , when we allocate the object using new(), the object is allocated on Heap, otherwise on Stack if not global or static.
In Java, when we only declare a variable of a class type, only a reference is created (memory is not allocated for the object).
To allocate memory to an object, we must use new(). So the object is always allocated memory on the heap.



There are two ways to create an object  of string in java:

        By string literal    String x = "Anunay"   String y = "Anunay"  in Memory only once Anunay is created and both x and y refernces that only.
        By new keyword    String x = new String("Anunay")  String x = new String("Anunay") if we create like this in the pool two times Anunay is created.


Stack vs Heap Memory Allocation


Stack Allocation: The allocation happens on contiguous blocks of memory. We call it a stack memory allocation because the allocation happens in the 
function call stack. The size of memory to be allocated is known to the compiler and whenever a function is called, its variables get memory
allocated on the stack. And whenever the function call is over, the memory for the variables is de-allocated. This all happens using some 
predefined routines in the compiler. A programmer does not have to worry about memory allocation and de-allocation of stack variables. 
This kind of memory allocation is also known as Temporary memory allocation because as soon as the method finishes its execution all the 
data belonging to that method flushes out from the stack automatically. 


Heap Allocation: The memory is allocated during the execution of instructions written by programmers. Note that the name heap has nothing to do 
with the heap data structure. It is called a heap because it is a pile of memory space available to programmers to allocate and de-allocate.
Every time when we made an object it always creates in Heap-space and the referencing information to these objects is always stored in 
Stack-memory. Heap memory allocation isn’t as safe as Stack memory allocation because the data stored in this space is accessible or visible 
to all threads. If a programmer does not handle this memory well, a memory leak can happen in the program.

------------------------------------------------------------------------------------------------------------------------------------------------------

Flow Control


if: if statement is the most simple decision-making statement. It is used to decide whether a certain statement or block of statements 
will be executed or not i.e if a certain condition is true then a block of statements is executed otherwise not. 

Syntax: 

        if(condition) 
        {
           // Statements to execute if
           // condition is true
        }



if-else: The if statement alone tells us that if a condition is true it will execute a block of statements and if the condition is false it won’t. 
But what if we want to do something else if the condition is false? Here comes the else statement. We can use the else statement with the if 
statement to execute a block of code when the condition is false. 

Syntax: 

        if (condition)
        {
            // Executes this block if condition is true
        }
        else
        {
            // Executes this block if condition is false
        }



switch-case: The switch statement is a multiway branch statement. It provides an easy way to dispatch execution to different parts of code based 
on the value of the expression. 

Syntax: 

        switch (expression)
        {
          case value1:
            statement1;
            break;
          case value2:
            statement2;
            break;
          .
          .
          case valueN:
            statementN;
            break;
          default:
            statementDefault;
        }

Break: In Java, a break is majorly used for: 
Terminate a sequence in a switch statement (discussed above).
To exit a loop.



Continue: Sometimes it is useful to force an early iteration of a loop. That is, you might want to continue running the loop but stop processing 
the remainder of the code in its body for this particular iteration. This is, in effect, a goto just past the body of the loop, to the loop’s end.
The continue statement performs such an action.

Java program to illustrate using continue in an if statement

        import java.util.*;
        
        class ContinueDemo {
        	public static void main(String args[])
        	{
        		for (int i = 0; i < 10; i++) {
        			// If the number is evenkip and continue
        			if (i % 2 == 0)
        			    continue;
        
        			// If number is odd, print it
        			System.out.print(i + " ");
        		}
        	}
        }


A while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. The while loop can be 
thought of as a repeating if statement. 

Syntax :

        while (boolean condition)
        {
           loop statements...
        }
        
        import java.io.*;
        
        class Hello {
        	public static void main (String[] args) {
        	int i=0;
        	while (i<=10)
        	{
        		System.out.println(i);
        		i++;
        	}
        	}
        }



for loop: for loop provides a concise way of writing the loop structure. Unlike a while loop, a for statement consumes the initialization, 
condition and increment/decrement in one line thereby providing a shorter, easy to debug structure of looping. 


        import java.io.*;
        
        class Hello {
        	public static void main (String[] args) {
        	for (int i=0;i<=10;i++)
        	{
        		System.out.println(i);
        	}
        	}
        }
        


for-each 


It starts with the keyword for like a normal for-loop.
Instead of declaring and initializing a loop counter variable, you declare a variable that is the same type as the base type of the array,
followed by a colon, which is then followed by the array name.
In the loop body, you can use the loop variable you created rather than using an indexed array element. 
 
It’s commonly used to iterate over an array or a Collections class (eg, ArrayList)
        
        import java.io.*; 
        
        class Easy 
        
        { 
        
        	public static void main(String[] args) 
        
        	{ 
        
        		// array declaration 
        
        		int ar[] = { 10, 50, 60, 80, 90 }; 
        
        		for (int element : ar) 
        
        			System.out.print(element + " "); 
        	} 
        }

------------------------------------------------------------------------------------------------------------------------------------------------------

Wrapper Class


Firstly the question that hits the programmers is when we have primitive data types then why does there arise a need for the concept of wrapper 
classes in java. It is because of the additional features being there in the Wrapper class over the primitive data types when it comes to usage. 
These methods include primarily methods like valueOf(), parseInt(), toString(), and many more.

A wrapper class wraps (encloses) around a data type and gives it an object appearance. Wrapper classes are final and immutable. Two concepts are 
there in the wrapper classes namely autoboxing and unboxing. 



AutoBoxing

procedure of converting a primitive value into an object of the corresponding wrapper class. For example, converting int to Integer class. 
The Java compiler applies autoboxing when a primitive value is:Passed as a parameter to a method that expects an object of the corresponding 
wrapper class.Assigned to a variable of the corresponding wrapper class.


CODE:

		import java .util.*;
		class home {
	
		public static void main(String args[]) {
			int x = 5;
			float y = 3.14f;
			long z=6000;
	
			// autoboxing
			Integer intobj = x;
			Float floatobj=y;
			Long longobj=z;
			// print 
			System.out.println(intobj);
			System.out.println(floatobj);
			System.out.println(longobj);
		}
	}
	

Unboxing

Unboxing is a procedure of converting an object of a wrapper type to its corresponding primitive value. For example conversion of Integer to int. 
The Java compiler applies to unbox when an object of a wrapper class is:Passed as a parameter to a method that expects a value of the
corresponding primitive type. Assigned to a variable of the corresponding primitive type.




Intialization of a Wrapper Class

Integer number = new Integer(5);  or  Integer number = Integer.valueOf(5);

				Character class->  Character ch = new Character('a');

        Methods in Character class                                                     Methods in Integer Class
        
        toString(char ch)                                                                   toString()
        Character.isLetter                                                      valueOf() : returns the Integer object
        Character.isDigit('0')
        Character.isWhitespace                                            parseInt() : returns int value by parsing the string
        isUpperCase
        Character.isLowerCase                                      compareTo() : Used to compare two Integer objects for numerical equality.
        toUpperCase       

------------------------------------------------------------------------------------------------------------------------------------------------------

STRINGS

        String str = "";  or String s = new String("");

StringBuilder

        StringBuilder sb = new StringBuilder();
        sb.append("GFG");



String Methods

        s.charAt(i)
        "GeeksforGeek".charAt(3); // returns  ‘k’
        
        GeeksforGeeks".substring(3); // returns “ksforGeeks”
        
        "GeeksforGeeks".substring(2, 5); // returns “eks”
        
        String s1 = ”Geeks”;
        String s2 = ”forGeeks”;
        String output = s1.concat(s2); // returns “GeeksforGeeks”
        
        String s = ”Learn Share Learn”;
        int output = s.indexOf(“Share”); // returns 6
        
        “Geeks”.equalsIgnoreCase(“Geeks”); // returns true
        Boolean out = “Geeks”.equals(“Geeks”); // returns true




String Tokenizer

StringTokenizer(String str, String delim, boolean flag)


1. If the flag is false, delimiter characters serve to separate tokens

Example:

Input : if string --> "hello geeks" and Delimiter is " ", then 
Output:  tokens are "hello" and "geeks".

2. If the flag is true, delimiter characters are considered to be tokens.

Example:

Input : String --> is "hello geeks"and Delimiter is " ", then 
Output: Tokens --> "hello", " " and "geeks".

3. Multiple delimiters can be chosen for a single string.

Example:

Syntax: StringTokenizer st1 = new StringTokenizer( "2+3-1*8/4", "+*-/");

Input : String --> is "2+3-1*8/4" and Delimiters are +,*,-,/ 
Output: Tokens --> "2","3","1","8","4".


------------------------------------------------------------------------------------------------------------------------------------------------------

Java Collections

1. ArrayList

ArrayList is a part of the Java collections framework and it is a class of java.util package. It provides us with dynamic arrays in Java. Though, it may be slower than standard arrays but can be helpful in programs where lots of manipulation in the array is needed.

No need to declare size before hand in arraylist.

Decalaration:

        ArrayList<Integer> l = new ArrayList<>();

Methods in ArrayList

        l.add(x)  --> appends element at last
        l.add(x,3)  --> At specific index
        l.set(y,e)  --> changing elements
        l.remove --> deleteing elements
        Collections.sort(l);  --> sorts the list
        list.size()  --> size of list
        int[] arr = l.toArray() --> conversion to array

------------------------------------------------------------------------------------------------------------------------------------------------------ 

2. HashSet

Objects that you insert in HashSet are not guaranteed to be inserted in the same order. Objects are inserted based on their hash code. no duplicates found in set


Declaration:  

        HashSet<Integer> set = new HashSet<>();

Methods in HashSet

        set.add(x);
        set.remove(x);
        using enhanced for loop is easy for iterating a hash set rather than using Iterator
        set.contains()
        set.size()
        isEmpty()


Linked Hash Set

        LinkedHashSet<String> hs = new LinkedHashSet<>();

Same as hash Set but in hashset the order is not retained where are it is not the case in LinkedHashSet


TreeSet

TreeSet is basically an implementation of a self-balancing binary search tree like a Red-Black Tree. Therefore operations like add, remove, and search takes O(log(N)) time. The reason is that in a self-balancing tree, it is made sure that the height of the tree is always O(log(N)) for all the operations. Therefore, this is considered as one of the most efficient data structures in order to store the huge sorted data and perform operations on it. However, operations like printing N elements in the sorted order take O(N) time.


        TreeSet<String> treeSet = new TreeSet<>();

However, the insertion order is not retained in the TreeSet. Internally, for every element, the values are compared and sorted in ascending order. 

------------------------------------------------------------------------------------------------------------------------------------------------------

3. Queue

Follows FIFO order

Being an interface the queue needs a concrete class for the declaration and the most common classes are the PriorityQueue and LinkedList in Java.

        Queue<String> queue = new LinkedList<>();

Methods:

        add, offer --> add elements to rear
        remove,poll --> removes elements from front
        peek(): Returns the element at the front of the queue without removing it orelse null

Other way

        Queue<String> pq = new PriorityQueue<>();

The insertion order is not retained in the PriorityQueue. The elements are stored based on the priority order which is ascending by default. 

iterating Queue

	Iterator iterator = pq.iterator();
 
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }

PriorityBlockingQueue: It is to be noted that both the implementations, the PriorityQueue and LinkedList are not thread-safe. PriorityBlockingQueue is one alternative implementation if thread-safe implementation is needed. PriorityBlockingQueue is an unbounded blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations. 


------------------------------------------------------------------------------------------------------------------------------------------------------

4. Deque

The Deque (double-ended queue) interface in Java is a subinterface of the Queue interface and extends it to provide a double-ended queue, which is a queue that allows elements to be added and removed from both ends.

        Deque<Integer> deque = new ArrayDeque<>();

methods

        deque.add --> inbuit adds at last
        deque.addFirst(40);  --> adds at First
        deque.addLast(30)   --> adds at Last
        .getFirst, .getlast
        peek, peekFirst, peekLast
        poll, poolLast
        .removeFirstOccurrence("x");
------------------------------------------------------------------------------------------------------------------------------------------------------        

5. HashMap

Hashmap stores as key value pairs ex: (a,1) (b,2) ....
 
        // Adding elements to the Map using standard put() method
        
	HashMap<String, Integer> map = new HashMap<>();
        map.put("vishal", 10);
        map.put("sachin", 30);
        map.put("vaibhav", 20);

Methods

        map.containsKey(); map.containsKey()
        map.get() map.put();
        map.keySet() --> gives all keys
        map.EntrySet() 

Iterating in HashMap

 	using Key Set
	for (String key : map.keySet()) {
            System.out.println("Key: " + key + ", Value: " + map.get(key));
        }

 	using entry Set
	for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }

 Inserting Data using map.getorDefault

  	for (String x: y) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }

The LinkedHashMap Class is just like HashMap with an additional feature of maintaining an order of elements inserted into it. 
TreeMap for Sorted Order.


------------------------------------------------------------------------------------------------------------------------------------------------------

EXCEPTION HANDLING

Exception Handling in Java is one of the effective means to handle runtime errors so that the regular flow of the application can be preserved. Java Exception Handling is a mechanism to handle runtime errors such as ClassNotFoundException, IOException, SQLException, RemoteException, etc.


Major reasons why an exception Occurs

	Invalid user input
	Device failure
	Loss of network connection
	Physical limitations (out-of-disk memory)
	Code errors
	Opening an unavailable file

Difference between an error and an exception

	Error: An Error indicates a serious problem that a reasonable application should not try to catch.
	Exception: Exception indicates conditions that a reasonable application might try to catch.








![Exceptions-in-Java-1-768](https://github.com/anunayreddy22/JAVA/assets/156383908/675b777a-37cd-4b28-b0d6-d816ec0dc0ba)








Checked Exceptions: Checked exceptions are called compile-time exceptions because these exceptions are checked at compile-time by the compiler.
 
Unchecked Exceptions: The unchecked exceptions are just opposite to the checked exceptions. The compiler will not check these exceptions at compile time. 


Methoda to Print Exception Information

1. printStackTrace()

		class Anunay { 
			public static void main (String[] args) { 
			int a=5; 
			int b=0; 
			try{ 
				System.out.println(a/b); 
			} 
			catch(ArithmeticException e){
   
				e.printStackTrace(); 
			} 
                    } 
		} 

Output

	java.lang.ArithmeticException: / by zero

 2. toString()


		class Anunay { 
			public static void main (String[] args) { 
			int a=5; 
			int b=0; 
			try{ 
				System.out.println(a/b); 
			} 
			catch(ArithmeticException e){ 
	 			System.out.println(e.toString()); 
			} 
		     } 
		} 


Built in Exceptions


  	ArithmeticException: It is thrown when an exceptional condition has occurred in an arithmetic operation.
	ArrayIndexOutOfBoundsException: It is thrown to indicate that an array has been accessed with an illegal index. 
	ClassNotFoundException: This Exception is raised when we try to access a class whose definition is not found
	FileNotFoundException: This Exception is raised when a file is not accessible or does not open.
	IOException: It is thrown when an input-output operation failed or interrupted
	InterruptedException: It is thrown when a thread is waiting, sleeping, or doing some processing, and it is interrupted.
	NoSuchFieldException: It is thrown when a class does not contain the field (or variable) specified
	NoSuchMethodException: It is thrown when accessing a method that is not found.
	NullPointerException: This exception is raised when referring to the members of a null object. Null represents nothing
	NumberFormatException: This exception is raised when a method could not convert a string into a numeric format.
	RuntimeException: This represents an exception that occurs during runtime.
	StringIndexOutOfBoundsException: It is thrown by String class methods to indicate that an index is either negative or greater than the size of the string
	IllegalArgumentException :  error statement when the method receives an argument which is not accurately fit to the given condition. 
	IllegalStateException :  error message when the method is not accessed for the particular operation in the application.


 Java Try Catch Block

 Try Block:

 The try block contains a set of statements where an exception can occur.

	try
	{
	    // statement(s) that might cause exception
	}

Catch Block:

The catch block is used to handle the uncertain condition of a try block. A try block is always followed by a catch block, which handles the exception that occurs in the associated try block.

	catch
	{
	   // statement(s) that handle an exception
	   // examples, closing a connection, closing file, exiting the process after writing details to a log file.
	}

Throw: 

The throw keyword is used to transfer control from the try block to the catch block. 


	class ThrowExcep {
		static void help()
		{
			try {
				throw new NullPointerException("error_unknown");
			}
			catch (NullPointerException e) {
				System.out.println("Caught inside help().");
				// rethrowing the exception
				throw e;
			}
		}
	
		public static void main(String args[])
		{
			try {
				help();
			}
			catch (NullPointerException e) {
				System.out.println("Caught in main error name given below:");
				System.out.println(e);
			}
		}
	}


Throws:

The throws keyword is used for exception handling without try & catch block. It specifies the exceptions that a method can throw to the caller and does not handle itself. 



	class ThrowsExecp {
	
		// This method throws an exception to be handled by caller or caller of caller and so on.
		static void fun() throws IllegalAccessException
		{
			System.out.println("Inside fun(). ");
			throw new IllegalAccessException("demo");
		}
	
		// This is a caller function 
		public static void main(String args[])
		{
			try {
				fun();
			}
			catch (IllegalAccessException e) {
				System.out.println("caught in main.");
			}
		}
	}

Finally Block:

It is executed after the catch block. We use it to put some common code (to be executed irrespective of whether an exception has occurred or not ) 

		try {
	            result = a / (b - c);
	            System.out.println("result" + result);
	        }
	 
	        catch (ArithmeticException e) {
	            System.out.println("Exception caught:Division by zero");
	        }
	 
	        finally {
	            System.out.println("I am in final block");
	        }
	







------------------------------------------------------------------------------------------------------------------------------------------------------

MULTITHREADING IN JAVA

Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.

Threads can be created by using two mechanisms : 

1.Extending the Thread class 
2.Implementing the Runnable Interface


1. By Extending Extending the Thread class 

We create a class that extends the java.lang.Thread class. This class overrides the run() method available in the Thread class. A thread begins its life inside run() method. We create an object of our new class and call start() method to start the execution of a thread.

Code:

	// Code for thread creation by extending the Thread class
	class MultithreadingDemo extends Thread {
		public void run()
		{
			try {
				// Displaying the thread that is running
				System.out.println("Thread " + Thread.currentThread().getId() + " is running");
			}
			catch (Exception e) {
				// Throwing an exception
				System.out.println("Exception is caught");
			}
		}
	}
	
	// Main Class
	public class Multithread {
		public static void main(String[] args)
		{
			int n = 8; // Number of threads
			for (int i = 0; i < n; i++) {
				MultithreadingDemo object = new MultithreadingDemo();
				object.start();
			}
		}
	}

2. Thread creation by implementing the Runnable Interface

We create a new class which implements java.lang.Runnable interface and override run() method. Then we instantiate a Thread object and call start() method on this object. 

Code:

	// Java code for thread creation by implementing the Runnable Interface
	class MultithreadingDemo implements Runnable {
		public void run()
		{
			try {
				// Displaying the thread that is running
				System.out.println("Thread " + Thread.currentThread().getId() + " is running");
			}
			catch (Exception e) {
				// Throwing an exception
				System.out.println("Exception is caught");
			}
		}
	}
	
	// Main Class
	class Multithread {
		public static void main(String[] args)
		{
			int n = 8; // Number of threads
			for (int i = 0; i < n; i++) {
			    Thread object = new Thread(new MultithreadingDemo());
			    object.start();
			}
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------

Differences

                                                Thread Class vs Runnable Interface 

	If we extend the Thread class, our class cannot extend any other class because Java doesn’t support multiple inheritance.
	If we implement the Runnable interface, our class can extend other base classes.
	By extending Thread class it provides some inbuilt methods like yield(), interrupt() etc. that are not available in Runnable interface.
	Using runnable will give you an object that can be shared amongst multiple threads. 

------------------------------------------------------------------------------------------------------------------------------------------------------
 Lifecycle and States of a Thread in Java

 	New State  --> When a new thread is created, it is in the new state.
	Runnable State -->  A thread that is ready to run is moved to a runnable state
	Blocked State --> The thread will be in blocked state when it is trying to acquire a lock but currently the lock is acquired by the other thread
	Waiting State  --> the thread will be in waiting state when it calls wait() method or join() method
	Timed Waiting State -->  A thread lies in this state until the timeout is completed or until a notification is received. Thread.sleep()
	Terminated State --> Exited wantedly or due to unforseen events.
 
------------------------------------------------------------------------------------------------------------------------------------------------------

Important Points

	1. The purpose of start() is to create a separate call stack for the thread. A separate call stack is created by it, and then run() is called by JVM.
	2. When a program calls the start() method, a new thread is created and then the run() method is executed. But if we directly call the run() method then no new thread will be 			created and run() method will be executed as a normal method 

------------------------------------------------------------------------------------------------------------------------------------------------------

SYNCHRONIZATION

Multi-threaded programs may often come to a situation where multiple threads try to access the same resources and finally produce erroneous and unforeseen results.Java Synchronization is used to make sure by some synchronization method that only one thread can access the resource at a given point in time.


Java Synchronized Blocks:

All synchronized blocks synchronize on the same object and can only have one thread executed inside them at a time. All other threads attempting to enter the synchronized block are blocked until the thread inside the synchronized block exits the block.

		synchronized(sync_object)
		{
		   // Access shared variables and other
		   // shared resources
		}


Types of Synchronization


Process Synchronization

	Technique used to coordinate the execution of multiple processes. It ensures that the shared resources are safe and in order.

Thread Synchronization

Thread Synchronization is used to coordinate and ordering of the execution of the threads in a multi-threaded program. There are two types of thread synchronization:
	
	Mutual Exclusive
	Cooperation (Inter-thread communication in Java)

Mutual Exclusive

Mutual Exclusive helps keep threads from interfering with one another while sharing data. There are three types of Mutual Exclusive mentioned below:

	Synchronized method.
	Synchronized block.
	Static synchronization

Cooperation (Inter-thread communication in Java)

Inter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.


------------------------------------------------------------------------------------------------------------------------------------------------------

Deadlock in Multithreading


 




![22-2](https://github.com/anunayreddy22/JAVA/assets/156383908/60648815-4502-42e6-97c9-2e0f6db7a808)


Deadlock is any situation in which no member of some group of entities can proceed because each waits for another member, including itself, to take action, such as sending a message or, more commonly, releasing a lock.

We can avoid dead lock condition by knowing its possibilities. We can’t completely remove its possibility but we can reduce.

Avoid Nested Locks : This is the main reason for dead lock. Dead Lock mainly happens when we give locks to multiple threads. 
Avoid Unnecessary Locks : We should have lock only those members which are required. Having lock on unnecessarily can lead to dead lock.
Using thread join : When one thread is waiting other to finish. If this condition occurs we can use Thread.join with maximum time you think the execution will take.


Deadlock Prevention:

The deadlock has the following characteristics:

		Mutual Exclusion
		Hold and Wait
		No Preemption
		Circular Wait

  By Eliminationg these Characteristics we can prevent deadlock.


  Deadlock Avoidance

     Resource Allocatiob Graph (banker's Algorithm)

------------------------------------------------------------------------------------------------------------------------------------------------------

Serialization


Serialization is a mechanism of converting the state of an object into a byte stream. Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory. This mechanism is used to persist the object.







![serialize-deserialize-java](https://github.com/anunayreddy22/JAVA/assets/156383908/ccb7403a-4853-4c51-92de-4d04e375c8e5)


The byte stream created is platform independent. So, the object serialized on one platform can be deserialized on a different platform. To make a Java object serializable we implement the java.io.Serializable interface.

The ObjectOutputStream class contains writeObject() method for serializing an Object. 


	public final void writeObject(Object obj) throws IOException


The ObjectInputStream class contains readObject() method for deserializing an object. 


	public final Object readObject() throws IOException,ClassNotFoundException
	
	
**Only the objects of those classes can be serialized which are implementing java.io.Serializable interface**


	// Java code for serialization and deserialization of a Java object
	import java.io.*;
	
	class Demo implements java.io.Serializable
	{
		public int a;
		public String b;
	
		// Default constructor
		public Demo(int a, String b)
		{
			this.a = a;
			this.b = b;
		}
	
	}
	
	class Test
	{
		public static void main(String[] args)
		{ 
			Demo object = new Demo(1, "geeksforgeeks");
			String filename = "file.ser";
			
			// Serialization 
			try
			{ 
				//Saving of object in a file
				FileOutputStream file = new FileOutputStream(filename);
				ObjectOutputStream out = new ObjectOutputStream(file);
				
				// Method for serialization of object
				out.writeObject(object);
				
				out.close();
				file.close();
				
				System.out.println("Object has been serialized");
	
			}
			
			catch(IOException ex)
			{
				System.out.println("IOException is caught");
			}
	
	
			Demo object1 = null;
	
			// Deserialization
			try
			{ 
				// Reading the object from a file
				FileInputStream file = new FileInputStream(filename);
				ObjectInputStream in = new ObjectInputStream(file);
				
				// Method for deserialization of object
				object1 = (Demo)in.readObject();
				
				in.close();
				file.close();
				
				System.out.println("Object has been deserialized ");
				System.out.println("a = " + object1.a);
				System.out.println("b = " + object1.b);
			}
			
			catch(IOException ex)
			{
				System.out.println("IOException is caught");
			}
			
			catch(ClassNotFoundException ex)
			{
				System.out.println("ClassNotFoundException is caught");
			}
	
		}
	}



------------------------------------------------------------------------------------------------------------------------------------------------------
                                                               *** THE END***

	                                                      "HAPPY LEARNING!"


















	
